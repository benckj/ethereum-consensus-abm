import networkx as nx
import numpy as np

from agent.constants import *
from agent.base_utils import *
from Gillespie import *
from agent.fixedEvents import *
from agent.randomProcess import *
from agent.node import *


class Model:
    '''
    This is used to build the network needed and parameterize the Gillespie Model
    Initiates the model and builds it around the parameters given model.gillespie.run to run the simulation.
    All objects are contained in the class.
    '''

    def __init__(self,
                 graph=None,
                 tau_block=None,
                 tau_attest=None,
                 seed=None,
                 malicious_percent=0
                 ):

        self.tau_block = tau_block
        self.tau_attest = tau_attest

        # Create network based on the given topology while initialization
        self.network = Network(graph)

        # Using a defined randomness for replication
        self.rng = np.random.default_rng(seed)

        no_of_malicious_nodes = np.floor(
            malicious_percent * len(self.network)).astype(int)

        no_of_honest_nodes = len(
            self.network) - no_of_malicious_nodes

        block = Block('0', 'genesis', 0)

        honest_nodes = [Node(block, self.rng)
                        for i in range(no_of_honest_nodes)]

        malicious_nodes = [Node(block, self.rng, malicious=True)
                           for i in range(no_of_malicious_nodes)]

        self.nodes = []
        self.nodes.extend([*honest_nodes, *malicious_nodes])

        self.validators = self.nodes

        # form normal network
        self.network.set_neighborhood(honest_nodes, malicious_nodes)

        self.edges = [(n, k) for n in self.nodes for k in n.neighbors]

        self.malicious_edges = [(n, k)
                                for n in self.nodes for k in n.malicious_neighbors]

        self.block_gossip_process = BlockGossipProcess(
            tau=self.tau_block, edges=self.edges)
        self.attestation_gossip_process = AttestationGossipProcess(
            tau=self.tau_attest, edges=self.edges)

        self.epoch_event = EpochEvent(
            SLOTS_PER_EPOCH*SECONDS_PER_SLOT, self.validators, rng=self.rng)
        
        self.slot_event = SlotEvent(
            SECONDS_PER_SLOT, self.validators, self.epoch_event, rng=self.rng)

        self.attestation_event = AttestationEvent(
            SECONDS_PER_SLOT, offset=4, slot_event=self.slot_event, epoch_event=self.epoch_event, rng=self.rng)

        self.adversary_event = AdversaryEvent(SECONDS_PER_SLOT, offset=5, slot_event=self.slot_event, epoch_event=self.epoch_event, rng=self.rng)

        self.processes = [self.block_gossip_process, self.attestation_gossip_process]
        self.fixed_events = [self.epoch_event, self.slot_event, self.attestation_event, self.adversary_event]

        self.gillespie = Gillespie(self.processes, self.rng)
        self.time = 0

        # Things for God's Eye View

    def run(self, stoping_time):

        while self.time < stoping_time:
            # generate next random increment time and save it in self.increment
            increment = self.gillespie.calculate_time_increment()

            # loop over fixed events and trigger if time passes fixed event time
            for fixed in self.fixed_events:
                fixed.trigger(self.time + increment)

            # select poisson process and trigger selected process
            next_process = self.gillespie.select_event()
            next_process.event(self.slot_event.counter)

            self.time += increment

    def results(self):
        """This functions returns a dictionary containing the
        experiments results, meaning the value functions computed
        on the final blocktree generated by the simulation.
        Returns:
        --------
        results : dictionary
        """
        # attestations from a god pov
        # for each node we have the latest attestations issued by the node
        # god_view_attestations = {node: node.attestations[node] for node in self.validators}
        god_view_blocks = set()

        for node in self.validators:
            god_view_blocks.update([block for block in node.local_blockchain])

        rng_node = self.rng.choice(self.validators)

        results_dict = {
            "mainchain_rate": rng_node.gasper.calculate_mainchain_rate(god_view_blocks),
            "branch_ratio": rng_node.gasper.calculate_branch_ratio(god_view_blocks),
            "blocktree_entropy": rng_node.gasper.calculate_entropy(god_view_blocks)
            }
        return results_dict


if __name__ == "__main__":
    # As mentioned in the Stochatic Modelling paper,
    # the number of neighbors fixed but have to experiment multiple topologies
    net_p2p = nx.random_degree_sequence_graph(
        [10 for i in range(100)])
    lcc_set = max(nx.connected_components(net_p2p), key=len)
    net_p2p = net_p2p.subgraph(lcc_set).copy()
    net_p2p = nx.convert_node_labels_to_integers(
        net_p2p, first_label=0)
    model = Model(
        graph=net_p2p,
        tau_block=1,
        tau_attest=1
    )
    model.run(14)
    print(model.results())
