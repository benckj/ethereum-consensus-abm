import networkx as nx
import numpy as np
import logging

from .constants import *
from .base_utils import *
from .Gillespie import *
from .fixedEvents import *
from .randomProcess import *
from .node import *


class Model:
    '''
    This is used to build the network needed and parameterize the Gillespie Model
    Initiates the model and builds it around the parameters given model.gillespie.run to run the simulation.
    All objects are contained in the class.
    '''

    def __init__(self,
                 graph=None,
                 tau_block=None,
                 tau_attest=None,
                 malicious_percent=0,
                 adversary_offset=5,
                 seed=None,
                 logging=logging
                 ):

        self.tau_block = tau_block
        self.tau_attest = tau_attest

        # Create network based on the given topology while initialization
        self.network = Network(graph)

        # Logging
        self.logging = logging
        self.logging.basicConfig(level=logging.ERROR)
        # Using a defined randomness for replication
        self.rng = np.random.default_rng(seed)

        no_of_malicious_nodes = np.floor(
            malicious_percent * len(self.network)).astype(int)

        no_of_honest_nodes = len(
            self.network) - no_of_malicious_nodes

        genesis_block = Block('0', 'genesis', 0)
        self.malicious_shared_state = NodeState(genesis_block)

        honest_nodes = [Node(genesis_block , i, self.rng)
                        for i in range(no_of_honest_nodes)]

        malicious_nodes = [Node(genesis_block , no_of_honest_nodes + i, self.rng, malicious=True, shared_state=self.malicious_shared_state, logging=self.logging)
                           for i in range(no_of_malicious_nodes)]

        self.nodes = []
        self.nodes.extend([*honest_nodes, *malicious_nodes])

        self.validators = self.nodes

        # form normal network
        self.network.set_neighborhood(self.nodes)

        self.edges = [(n, k) for n in self.nodes for k in n.neighbors]

        self.block_gossip_process = BlockGossipProcess(
            tau=self.tau_block, edges=self.edges)
        self.attestation_gossip_process = AttestationGossipProcess(
            tau=self.tau_attest, edges=self.edges)

        self.epoch_event = EpochEvent(
            SLOTS_PER_EPOCH*SECONDS_PER_SLOT, self.validators, rng=self.rng)

        self.slot_event = SlotEvent(
            SECONDS_PER_SLOT, self.validators, self.epoch_event, rng=self.rng)

        self.attestation_event = AttestationEvent(
            SECONDS_PER_SLOT, offset=4, slot_event=self.slot_event, epoch_event=self.epoch_event, rng=self.rng)

        self.adversary_event = AdversaryEvent(
            SECONDS_PER_SLOT, offset=adversary_offset, slot_event=self.slot_event, epoch_event=self.epoch_event, rng=self.rng)

        self.processes = [self.block_gossip_process,
                          self.attestation_gossip_process]
        self.fixed_events = [self.epoch_event, self.slot_event,
                             self.attestation_event, self.adversary_event]

        self.gillespie = Gillespie(self.processes, self.rng)
        self.time = 0

        # Things for God's Eye View
        self.god_view_blocks = set()

    def run(self, stoping_time):

        while self.time < stoping_time:
            # generate next random increment time and save it in self.increment
            increment = self.gillespie.calculate_time_increment()

            # loop over fixed events and trigger if time passes fixed event time
            for fixed in self.fixed_events:
                response = fixed.trigger(self.time + increment)

            # select poisson process and trigger selected process
            next_process = self.gillespie.select_event()
            next_process.event(self.slot_event.counter)

            self.time += increment

    def results(self):
        """This functions returns a dictionary containing the
        experiments results, meaning the value functions computed
        on the final blocktree generated by the simulation.
        Returns:
        --------
        results : dictionary
        """
        # attestations from a god pov
        # for each node we have the latest attestations issued by the node
        # god_view_attestations = {node: node.attestations[node] for node in self.validators}
        

        for node in self.validators:
            self.god_view_blocks.update([block for block in node.state.local_blockchain])

        rng_node = self.rng.choice(self.validators)

        rng_node.gasper.lmd_ghost(rng_node.state.local_blockchain,rng_node.state.attestations)

        results_dict = {
            "mainchain_rate": rng_node.gasper.calculate_mainchain_rate(self.god_view_blocks),
            "branch_ratio": rng_node.gasper.calculate_branch_ratio(self.god_view_blocks),
            "blocktree_entropy": rng_node.gasper.calculate_entropy(self.god_view_blocks)
        }
        return results_dict

