import networkx as nx
import numpy as np
import logging

from .constants import *
from .base_utils import *
from .Gillespie import *


from .fixedEvents import *
from .random_process import *
from .node import *


class Model:
    '''
    This is used to build the network needed and parameterize the Gillespie Model
    Initiates the model and builds it around the parameters given model.gillespie.run to run the simulation.
    All objects are contained in the class.
    '''

    def __init__(self,
                 graph=None,
                 tau_block=None,
                 tau_attest=None,
                 malicious_percent=0,
                 adversary_offset=0,
                 proposer_vote_boost=0,
                 seed=None,
                 logging=logging
                 ):

        self.tau_block = tau_block
        self.tau_attest = tau_attest
        self.proposer_vote_boost = proposer_vote_boost

        # Create network based on the given topology while initialization
        self.network = Network(graph)

        # Logging
        self.logging = logging
        self.logging.basicConfig(level=logging.DEBUG)

        # Using a defined randomness for replication
        self.rng = np.random.default_rng(seed)

        no_of_malicious_nodes = np.floor(
            malicious_percent * len(self.network)).astype(int)

        no_of_honest_nodes = len(
            self.network) - no_of_malicious_nodes

        self.genesis_block = Block('0', 'genesis', 0)

        honest_nodes = [Node(self.genesis_block, i, self.rng)
                        for i in range(no_of_honest_nodes)]

        malicious_nodes = [Node(self.genesis_block, no_of_honest_nodes + i, self.rng, malicious=True, logging=self.logging)
                           for i in range(no_of_malicious_nodes)]

        self.nodes = []
        self.nodes.extend([*honest_nodes, *malicious_nodes])

        self.validators = self.nodes

        # form normal network
        self.network.set_neighborhood(self.nodes)

        self.edges = [(n, k) for n in self.nodes for k in n.neighbors]

        self.chain_state = ChainState(
            0, 0, 0, 0, self.proposer_vote_boost, self.genesis_block, self.logging)

        self.block_gossip_process = BlockGossipProcess(
            tau=self.tau_block, edges=self.edges, chainstate=self.chain_state, rng=self.rng)

        self.attestation_gossip_process = AttestationGossipProcess(
            tau=self.tau_attest, edges=self.edges, chainstate=self.chain_state, rng=self.rng)

        self.epoch_event = EpochEvent(
            SLOTS_PER_EPOCH*SECONDS_PER_SLOT, self.validators, self.chain_state, rng=self.rng, logging=self.logging)

        self.slot_event = SlotEvent(
            SECONDS_PER_SLOT, self.validators, self.epoch_event, self.chain_state, rng=self.rng, logging=self.logging)

        self.attestation_event = AttestationEvent(
            SECONDS_PER_SLOT, offset=SECONDS_PER_SLOT/INTERVALS_PER_SLOT, epoch_event=self.epoch_event, chainstate=self.chain_state, rng=self.rng, logging=self.logging)

        self.adversary_event = AdversaryEvent(
            SECONDS_PER_SLOT, offset=adversary_offset, epoch_event=self.epoch_event, chainstate=self.chain_state, rng=self.rng, logging=self.logging)

        self.processes = [self.block_gossip_process,
                          self.attestation_gossip_process]
        self.fixed_events = [self.epoch_event, self.slot_event,
                             self.attestation_event, self.adversary_event]

        self.gillespie = Gillespie(self.processes, self.rng)
        self.time = 0

        # Things for God's Eye View
        self.god_view_blocks = set()

    def run(self, stoping_time):
        while self.time < stoping_time:
            # generate next random increment time and save it in self.increment
            increment = self.gillespie.calculate_time_increment()

            # loop over fixed events and trigger if time passes fixed event time
            for fixed in self.fixed_events:
                fixed.trigger(self.time + increment)

            # select poisson process and trigger selected process
            next_process = self.gillespie.select_event()
            next_process.event()

            self.time += increment
            self.chain_state.update_time(self.time)

        self.chain_state.update_time(self.time)
        self.chain_state.update_slot(self.chain_state.slot+1)

    def results(self):
        """This functions returns a dictionary containing the
        experiments results, meaning the value functions computed
        on the final blocktree generated by the simulation.
        Returns:
        --------
        results : dictionary
        """
        analyse_node = Node(self.genesis_block,
                            len(self.network)+1, self.rng)
        analyse_node.state.local_blockchain = self.chain_state.god_view_blocks
        for slot, node_attestaions in self.chain_state.god_view_attestations.items():
            for node, block in node_attestaions.items():
                analyse_node.state.add_attestation(self.chain_state,
                                                   Attestation(node, block, slot))
        analyse_node.gasper.lmd_ghost(self.chain_state, analyse_node.state)

        malicious_blocks_count = len([
            block for block in self.chain_state.god_view_blocks if block.malicious])

        malicious_blocks_final_count = len(
            [block for _, block in analyse_node.gasper.consensus_chain.items() if block.malicious])

        delayed_block_influence = len([1 for slot in self.chain_state.reorgs if [
                                       block for block in self.chain_state.god_view_blocks if block.slot == slot+1 and block.parent.slot != slot]])

        reorg_count = len([1 for slot in self.chain_state.reorgs if (slot+2) in analyse_node.gasper.consensus_chain.keys()
                           and slot in analyse_node.gasper.consensus_chain.keys()
                           and analyse_node.gasper.consensus_chain[slot+2].parent == analyse_node.gasper.consensus_chain[slot]
                           and (slot+1) not in analyse_node.gasper.consensus_chain.keys()])

        protected_reorgs = len([1 for slot in self.chain_state.reorgs
                                if (slot+1) in analyse_node.gasper.consensus_chain.keys()
                                and (slot-1) in analyse_node.gasper.consensus_chain.keys()
                                and analyse_node.gasper.consensus_chain[slot+1].parent == analyse_node.gasper.consensus_chain[slot-1]
                                and slot not in analyse_node.gasper.consensus_chain.keys()])

        attackable_slot_count = len(self.chain_state.reorgs)

        results_dict = {
            "mainchain_rate": analyse_node.gasper.calculate_mainchain_rate(self.chain_state.god_view_blocks),
            "branch_ratio": analyse_node.gasper.calculate_branch_ratio(self.chain_state.god_view_blocks),
            "blocktree_entropy": analyse_node.gasper.calculate_entropy(self.chain_state.god_view_blocks),
            "attack_probability": attackable_slot_count / (self.chain_state.slot-1),
            "attackable_slots_count": attackable_slot_count,
            "successful_reorgs": reorg_count,
            "protected_reorgs": protected_reorgs,
            "failed_reorgs": attackable_slot_count - reorg_count,
            "total_blocks": len(self.chain_state.god_view_blocks),
            "total_final_blocks": len(analyse_node.gasper.consensus_chain.items()),
            "total_malicious_blocks_final": malicious_blocks_final_count,
            "malicious_blocks_proposal_percent": malicious_blocks_count / len(self.chain_state.god_view_blocks),
            "malicious_blocks_finality_percent": malicious_blocks_final_count / len(analyse_node.gasper.consensus_chain.items()),
            "malicious_finality_probability": malicious_blocks_final_count / max(malicious_blocks_count, 1),
            "delayed_block_influence": delayed_block_influence
        }

        return results_dict
